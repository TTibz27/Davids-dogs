INCLUDE "hardware.inc"
INCLUDE "src/labels/wram.z80"
include "src/screens/eat-screen/anim-enum.z80"

SECTION "EatScreenDraw", ROM0
drawMain::

    ;BLANK OAM BUFFER
    ld b, $00;
    ld hl, plate_dog_sprite_buffer;
    ld de, 68;  68 is debug:  hand_anim_sprite_buffer_end - plate_dog_sprite_buffer; ;; Last item defined - first item defined 
    call memfill;
    ;TODO - instead of blanking all of the OAM every single frame, it would proably be better to flag when this needs updated, check if flag exists, then run this
    ;TODO - that could be improved on by flagging specific objects that need updated or whatever. but like, I am pressed for time so whatever.
    ;(also to hide sprites you can set their y values out of bounds instead of blanking the whole object, that would probably be better than blanking everything.)

    ld hl, wOAMBufferStart
    ld b, h ;; load buffer address into bc, bc should always have the next available OAM location after calls
    ld c, l
   
    call DrawAnimations
    call drawHotdogSprites

ret

drawHotdogSprites:: ; assume buffer address is in BC
    push bc


.checkRightDog
    ld a, [wHotDogState]
    bit 0, a
    jp z, .checkLeftDog

.drawRightDog  
    ld hl, plate_dog_sprite_buffer  + 12 
    ld bc, right_table_dog
    ld de, 12 ;; 12 bytes = 3 obj = 1 hotdog
    call memcpy

.checkLeftDog
    ld a, [wHotDogState]
    bit 1, a
    jp z ,.copySpriteOAMBufferDogs

.drawleftDog
     ld hl, plate_dog_sprite_buffer  
     ld bc, left_table_dog
     ld de, 12 ;; 12 bytes = 3 obj = 1 hotdog
     call memcpy

.copySpriteOAMBufferDogs
    ;Debug to load the static test oam sprites
    ; ld hl, plate_dog_sprite_buffer  ; This is the OAM Mirror address, it should probably exist in hardware defines
    ; ld bc, test_oam_sprite
    ; ld de, test_oam_sprite_end - test_oam_sprite
    ; call memcpy
   
    pop bc
    ld h, b
    ld l, c
    ld bc, plate_dog_sprite_buffer
    ld de, plate_dog_sprite_buffer_end - plate_dog_sprite_buffer
    call memcpy_keepaddr;; this keeps the final address in bc
    ret 


DrawAnimations::
    push bc
    ;Writing text to help view stuff in ram
    ld hl, debug 
    ld bc, debug_label
    ld de, 14
    call memcpy
    ;; this is effectively a big switch
    ld a, [wPlayerActions]
    cp a, EATANIM_LEFT_REACH
    jr z, .drawLeftReach
    cp a, EATANIM_RIGHT_REACH
    jr z, .drawRightReach
    cp a, EATANIM_HOLD_LEFT
    jr z, .drawLeftHold
    cp a, EATANIM_HOLD_RIGHT
    jr z, .drawRightHold
    cp a, EATANIM_HOLD_BOTH
    jr z, .drawBothHold 

    jr .copySpriteOAMBufferAnims ;; default case



.drawLeftReach
    ld hl, hand_anim_sprite_buffer  
    ld bc, left_hand_grabbing_dog
    ld de, 44 ;; 44bytes = 11 obj 
    call memcpy
jr .copySpriteOAMBufferAnims

.drawRightReach
    ld hl, hand_anim_sprite_buffer  
    ld bc, right_hand_grabbing_dog
    ld de, 44 ;; 44bytes = 11 obj 
    call memcpy
jr .copySpriteOAMBufferAnims


.drawLeftHold
    ld hl, hand_anim_sprite_buffer  
    ld bc, left_hand_idle
    ld de, 16;; 44bytes = 11 obj 
    call memcpy
    jr .copySpriteOAMBufferAnims
.drawRightHold
    ld hl, hand_anim_sprite_buffer  
    ld bc, right_hand_idle
    ld de, 16 ;; 44bytes = 11 obj 
    call memcpy
    jr .copySpriteOAMBufferAnims
.drawBothHold
    ld hl, hand_anim_sprite_buffer  
    ld bc, left_hand_idle
    ld de, 32;; 44bytes = 11 obj 
    call memcpy

.copySpriteOAMBufferAnims
    pop bc
    ld h, b
    ld l, c
    ld bc, hand_anim_sprite_buffer
    ld de, hand_anim_sprite_buffer_end - hand_anim_sprite_buffer
    call memcpy_keepaddr ;; load buffer address back into bc

    ret

 ; it would probably be good to dynamically account for the tile number based on when it is loaded into RAM if possible
 ; right now we are hardcoding tile numbers straight from the debugger so whatever I guess.


    ; 10 OBJECTS GIVEN TO THE TIMER, GREAT MINERS OF AND CRAFTSMAN OF THE HOTDOG HALL
    ;12 OBJECTS GIVEN TO THE HOTDOGS, THE WISEST AND FAIREST OF ALL BEINGS 
left_table_dog:
    db $84, $24, $06, $00  ;y- loc, x - loc, tile #,  flags ,
    db $84, $2c, $07, $00  ;y- loc, x - loc, tile #,  flags ,
    db $84, $34, $08, $00  ;y- loc, x - loc, tile #,  flags ,

right_table_dog:
    db $84, $74, $06, $00  ;y- loc, x - loc, tile #,  flags ,
    db $84, $7c, $07, $00  ;y- loc, x - loc, tile #,  flags ,
    db $84, $84, $08, $00  ;y- loc, x - loc, tile #,  flags ,
    ;left hand dog 
    ; db $84, $24, $06, $00  ;y- loc, x - loc, tile #,  flags ,
    ; db $84, $2c, $07, $00  ;y- loc, x - loc, tile #,  flags ,
    ; db $84, $34, $08, $00  ;y- loc, x - loc, tile #,  flags ,
    ; ;right hand dog 
    ; db $84, $74, $06, $00  ;y- loc, x - loc, tile #,  flags ,
    ; db $84, $7c, $07, $00  ;y- loc, x - loc, tile #,  flags ,
    ; db $84, $84, $08, $00  ;y- loc, x - loc, tile #,  flags ,

    ;11 OBJECTS GIVEN TO THE HANDS, WHO ABOVE ALL ELSE DESIRE POWER
left_hand_grabbing_dog:
    db $68, $3A, $0E, %00010000  ;y- loc, x - loc, tile #,  flags (alt pallette),
    db $68, $42, $0F, %00010000   ;y- loc, x - loc, tile #,  flags ,
    
    db $70, $32, $10, %00010000  ;y- loc, x - loc, tile #,  flags ,
    db $70, $3A, $11, %00010000  ;y- loc, x - loc, tile #,  flags ,
    db $70, $42, $12, %00010000   ;y- loc, x - loc, tile #,  flags , 

    db $78, $2A, $13, %00010000   ;y- loc, x - loc, tile #,  flags ,
    db $78, $32, $14, %00010000   ;y- loc, x - loc, tile #,  flags ,
    db $78, $3A, $15, %00010000   ;y- loc, x - loc, tile #,  flags ,

    db $80, $2A, $16, %00010000   ;y- loc, x - loc, tile #,  flags ,
    db $80, $32, $17, %00010000   ;y- loc, x - loc, tile #,  flags ,
    db $80, $3A, $18, %00010000   ;y- loc, x - loc, tile #,  flags ,

    right_hand_grabbing_dog:
    db $68, $66, $0F, %00110000  ;y- loc, x - loc, tile #,  flags (x-flip , alt pallette),
    db $68, $6e, $0E, %00110000   ;y- loc, x - loc, tile #,  flags ,
    
    db $70, $66, $12, %00110000  ;y- loc, x - loc, tile #,  flags ,
    db $70, $6e, $11, %00110000  ;y- loc, x - loc, tile #,  flags ,
    db $70, $76, $10, %00110000   ;y- loc, x - loc, tile #,  flags , 

    db $78, $6e, $15, %00110000   ;y- loc, x - loc, tile #,  flags ,
    db $78, $76, $14, %00110000   ;y- loc, x - loc, tile #,  flags ,
    db $78, $7e, $13, %00110000   ;y- loc, x - loc, tile #,  flags ,

    db $80, $6e, $18, %00110000   ;y- loc, x - loc, tile #,  flags ,
    db $80, $76, $17, %00110000   ;y- loc, x - loc, tile #,  flags ,
    db $80, $7e, $16, %00110000   ;y- loc, x - loc, tile #,  flags ,

    left_hand_idle:
    db $70, $38, $19, %00010000   ;y- loc, x - loc, tile #,  flags ,
    db $70, $40, $1a, %00010000  ;y- loc, x - loc, tile #,  flags ,
    db $78, $38, $1b, %00010000  ;y- loc, x - loc, tile #,  flags ,
    db $78, $40, $1c, %00010000   ;y- loc, x - loc, tile #,  flags , 

    right_hand_idle:
    db $70, $68, $19, %00010000   ;y- loc, x - loc, tile #,  flags ,
    db $70, $70, $1a, %00010000  ;y- loc, x - loc, tile #,  flags ,
    db $78, $68, $1b, %00010000  ;y- loc, x - loc, tile #,  flags ,
    db $78, $70, $1c, %00010000   ;y- loc, x - loc, tile #,  flags , 


    

    ; we've got 3 objects left on the idle screen at this point.
    ;2 for the eyes?
    ;1 for mouth?

debug_label:
    db "BIG LIGMA       "




SECTION "EatScreenDrawVars", wramx
debug:
    ds 14;
eat_screen_idle_draw_flags::
    db
;  --------------------FLAGS --------------------------------    
;       ???             | draw left dog | draw right dog
;-------------------------------------------------------------
; bits    7-2           |       1       |      0

plate_dog_sprite_buffer::
    ds 24;(4 * 6) , uses 6 objects,
plate_dog_sprite_buffer_end::
hand_anim_sprite_buffer::
    ds 44 ;(4 * 11) 8 objects
hand_anim_sprite_buffer_end::
